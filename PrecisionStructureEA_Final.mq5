//+------------------------------------------------------------------+\n//|                                    PrecisionStructureEA_Final.mq5 |\n//|                          High-Precision Market Structure Trading  |\n//|                                       Copyright 2025, TradePro MT |\n//|                                         https://www.tradepro.com/ |\n//+------------------------------------------------------------------+\n#property copyright "Copyright 2025, TradePro MT"\n#property link      "https://www.tradepro.com/"\n#property version   "3.00"\n#property strict\n#property description "Production-Ready High precision market structure EA with support/resistance trading"\n\n#include <Trade/Trade.mqh>\n#include <Arrays/ArrayObj.mqh>\n\nenum ENUM_SESSION_FILTER {\n   ALL_SESSIONS,            // All Sessions\n   ASIAN_SESSION,           // Asian Session (00:00-08:00)\n   LONDON_SESSION,          // London Session (08:00-16:00)\n   NEW_YORK_SESSION,        // New York Session (13:00-21:00)\n   LONDON_NEW_YORK_OVERLAP, // London-New York Overlap (13:00-16:00)\n   CUSTOM_HOURS             // Custom Hours\n};\n\nenum ENUM_DAYS_FILTER {\n   ALL_DAYS,     // All Days\n   WEEKDAYS,     // Mon-Fri\n   WEEKEND,      // Sat-Sun\n   MON,          // Monday\n   TUE,          // Tuesday\n   WED,          // Wednesday\n   THU,          // Thursday\n   FRI           // Friday\n};\n\nenum ENUM_TIMEFRAME_SELECTION {\n   TIMEFRAME_M5,    // 5 Minutes\n   TIMEFRAME_M15,   // 15 Minutes\n   TIMEFRAME_M30,   // 30 Minutes\n   TIMEFRAME_H1,    // 1 Hour\n   TIMEFRAME_H4,    // 4 Hours\n   TIMEFRAME_D1     // Daily\n};\n\ninput string GeneralGroup = "=== GENERAL SETTINGS ===";\ninput int    MagicNumber = 218215215;\ninput double LotSize = 0.01;\ninput bool   UseAutoLotSize = false;\ninput double RiskPercent = 1.0;\ninput int    MaxTrades = 3;\ninput bool   UseVisualMode = true;\ninput bool   EnableDebugLogging = true;\n\ninput string TimeframeGroup = "=== TIMEFRAME SETTINGS ===";\ninput ENUM_TIMEFRAME_SELECTION MainTimeframe = TIMEFRAME_H1;\ninput ENUM_TIMEFRAME_SELECTION ConfirmTimeframe = TIMEFRAME_M15;\ninput ENUM_TIMEFRAME_SELECTION ExecutionTimeframe = TIMEFRAME_M5;\n\ninput string StructureGroup = "=== STRUCTURE DETECTION ===";\ninput int    SwingSensitivity = 5;\ninput int    MaxHistoricalLevels = 10;\ninput int    MinSwingStrength = 10;\ninput bool   UseAdaptiveSwing = true;\ninput double StructureAccuracyThreshold = 80.0;\n\ninput string FilterGroup = "=== SESSION & DAY FILTERS ===";\ninput ENUM_SESSION_FILTER SessionFilter = ALL_SESSIONS;\ninput int    TradingStartHour = 8;\ninput int    TradingEndHour = 16;\ninput ENUM_DAYS_FILTER DayFilter = WEEKDAYS;\ninput bool   AvoidHighImpactNews = true;\n\ninput string TradeGroup = "=== TRADE PARAMETERS ===";\ninput int    StopLossPips = 10;\ninput int    TakeProfitPips = 30;\ninput bool   UseStructureSL = true;\ninput bool   UseStructureTP = true;\ninput bool   UseTrailingStop = true;\ninput int    TrailingStartPips = 10;\ninput int    TrailingStepPips = 5;\ninput bool   UseBreakEven = true;\ninput int    BreakEvenPips = 15;\ninput int    BreakEvenStopPips = 3;\n\ninput string NotificationGroup = "=== NOTIFICATION SETTINGS ===";\ninput bool   UseTelegram = true;\ninput string TelegramChatID = "394543952";\ninput bool   UsePushNotifications = false;\ninput bool   UseEmailNotifications = false;\n\n#define TELEGRAM_BOT_TOKEN "8472308793:AAGirMjp6R5Fjvbm8W5_X7EpL8LDt-LPikw"\n#define TELEGRAM_URL "https://api.telegram.org/"\n\nCTrade Trade;\nENUM_TIMEFRAMES g_mainTF, g_confirmTF, g_executionTF;\ndatetime lastBarTime = 0;\ndatetime lastNewsCheckTime = 0;\nstatic int tickCounter = 0;\n\ndouble higherHighs[], higherLows[], lowerHighs[], lowerLows[];\ndatetime higherHighsTime[], higherLowsTime[], lowerHighsTime[], lowerLowsTime[];\nint higherHighsCount = 0, higherLowsCount = 0, lowerHighsCount = 0, lowerLowsCount = 0;\n\ndouble buyZoneBuffer[], sellZoneBuffer[];\ndouble stopLossBuffer[], takeProfitBuffer[];\n\nclass TradeInfo : public CObject {\npublic:\n   ulong ticket;\n   ENUM_POSITION_TYPE type;\n   double openPrice;\n   double stopLoss;\n   double takeProfit;\n   bool isTrailingActive;\n   datetime openTime;\n   \n   TradeInfo() : ticket(0), type(POSITION_TYPE_BUY), openPrice(0), stopLoss(0),  \n                 takeProfit(0), isTrailingActive(false), openTime(0) {}\n};\n\nCArrayObj activeTrades;\n\nint OnInit() {\n   Trade.SetExpertMagicNumber(MagicNumber);\n   Trade.SetMarginMode();\n   Trade.SetTypeFillingBySymbol(_Symbol);\n   \n   g_mainTF = ConvertTimeframeEnum(MainTimeframe);\n   g_confirmTF = ConvertTimeframeEnum(ConfirmTimeframe);\n   g_executionTF = ConvertTimeframeEnum(ExecutionTimeframe);\n   \n   ArrayResize(higherHighs, MaxHistoricalLevels);\n   ArrayResize(higherLows, MaxHistoricalLevels);\n   ArrayResize(lowerHighs, MaxHistoricalLevels);\n   ArrayResize(lowerLows, MaxHistoricalLevels);\n   \n   ArrayResize(higherHighsTime, MaxHistoricalLevels);\n   ArrayResize(higherLowsTime, MaxHistoricalLevels);\n   ArrayResize(lowerHighsTime, MaxHistoricalLevels);\n   ArrayResize(lowerLowsTime, MaxHistoricalLevels);\n   \n   if(!InitializeMarketStructurePoints()) {\n      PrintError("Failed to initialize market structure points");\n      return INIT_FAILED;\n   }\n   \n   if(UseVisualMode) {\n      UpdatePotentialEntryZones();\n      VisualizeStructureLevels();\n   }\n   \n   if(UseTelegram && TelegramChatID != "")\n      SendTelegramNotification("âœ… PrecisionStructureEA initialized on " + _Symbol + " " + EnumToString(g_mainTF));\n   \n   PrintInfo("EA Initialized - Market Structure: HH=" + IntegerToString(higherHighsCount) +  \n             ", HL=" + IntegerToString(higherLowsCount) + ", LH=" + IntegerToString(lowerHighsCount) +  \n             ", LL=" + IntegerToString(lowerLowsCount));\n   \n   return INIT_SUCCEEDED;\n}\n\nvoid OnDeinit(const int reason) {\n   if(UseTelegram && TelegramChatID != "")\n      SendTelegramNotification("ðŸ›‘ PrecisionStructureEA stopped on " + _Symbol);\n   \n   ObjectsDeleteAll(0, "StructureEA_");\n   ObjectsDeleteAll(0, "EntryZone_");\n   ObjectsDeleteAll(0, "BuyZone_");\n   ObjectsDeleteAll(0, "SellZone_");\n   ObjectsDeleteAll(0, "Entry_Buy_");\n   ObjectsDeleteAll(0, "Entry_Sell_");\n   \n   activeTrades.Clear();\n   PrintInfo("EA Deinitialized - Reason: " + IntegerToString(reason));\n}\n\nvoid OnTick() {\n   tickCounter++;\n   \n   bool frequentCheckPerformed = FrequentSignalCheck();\n   if(frequentCheckPerformed) return;\n   \n   if(!IsNewBar()) {\n      if(tickCounter % 50 == 0 && UseVisualMode)\n         UpdatePotentialEntryZones();\n      return;\n   }\n   \n   tickCounter = 0;\n   \n   if(!IsTradingSession()) {\n      if(EnableDebugLogging && MathMod(TimeCurrent(), 600) < 5)\n         PrintDebug("Outside trading session");\n      return;\n   }\n   \n   if(!IsTradingDay()) {\n      if(EnableDebugLogging && MathMod(TimeCurrent(), 600) < 5)\n         PrintDebug("Not a trading day");\n      return;\n   }\n   \n   if(AvoidHighImpactNews && IsHighImpactNews()) {\n      PrintDebug("Avoiding high impact news period");\n      return;\n   }\n   \n   UpdateMarketStructure();\n   CheckForBuySignals();\n   CheckForSellSignals();\n   ManageOpenPositions();\n   \n   if(UseVisualMode) {\n      UpdatePotentialEntryZones();\n      VisualizeStructureLevels();\n   }\n}\n\nbool IsNewBar() {\n   static datetime lastBar = 0;\n   datetime currBar = iTime(_Symbol, g_executionTF, 0);\n   \n   if(currBar != lastBar) {\n      lastBar = currBar;\n      return true;\n   }\n   return false;\n}\n\nENUM_TIMEFRAMES ConvertTimeframeEnum(ENUM_TIMEFRAME_SELECTION tf) {\n   switch(tf) {\n      case TIMEFRAME_M5: return PERIOD_M5;\n      case TIMEFRAME_M15: return PERIOD_M15;\n      case TIMEFRAME_M30: return PERIOD_M30;\n      case TIMEFRAME_H1: return PERIOD_H1;\n      case TIMEFRAME_H4: return PERIOD_H4;\n      case TIMEFRAME_D1: return PERIOD_D1;\n      default: return PERIOD_H1;\n   }\n}\n\nbool FrequentSignalCheck() {\n   static datetime lastCheckTime = 0;\n   datetime currentTime = TimeCurrent();\n   \n   if(currentTime - lastCheckTime >= 20) {\n      lastCheckTime = currentTime;\n      \n      if(!IsTradingSession() || !IsTradingDay())\n         return false;\n      \n      if(AvoidHighImpactNews && IsHighImpactNews())\n         return false;\n      \n      CheckForBuySignals();\n      CheckForSellSignals();\n      ManageOpenPositions();\n      \n      if(UseVisualMode) {\n         UpdatePotentialEntryZones();\n         VisualizeStructureLevels();\n      }\n      \n      return true;\n   }\n   return false;\n}\n\nbool IsTradingSession() {\n   MqlDateTime dt;\n   TimeToStruct(TimeCurrent(), dt);\n   int hour = dt.hour;\n   \n   switch(SessionFilter) {\n      case ALL_SESSIONS:\n         return true;\n      case ASIAN_SESSION:\n         return (hour >= 0 && hour < 8);\n      case LONDON_SESSION:\n         return (hour >= 8 && hour < 16);\n      case NEW_YORK_SESSION:\n         return (hour >= 13 && hour < 21);\n      case LONDON_NEW_YORK_OVERLAP:\n         return (hour >= 13 && hour < 16);\n      case CUSTOM_HOURS:\n         return (hour >= TradingStartHour && hour < TradingEndHour);\n      default:\n         return true;\n   }\n}\n\nbool IsTradingDay() {\n   MqlDateTime dt;\n   TimeToStruct(TimeCurrent(), dt);\n   int day = dt.day_of_week;\n   \n   switch(DayFilter) {\n      case ALL_DAYS: return true;\n      case WEEKDAYS: return (day >= 1 && day <= 5);\n      case WEEKEND: return (day == 0 || day == 6);\n      case MON: return (day == 1);\n      case TUE: return (day == 2);\n      case WED: return (day == 3);\n      case THU: return (day == 4);\n      case FRI: return (day == 5);\n      default: return true;\n   }\n}\n\nbool IsHighImpactNews() {\n   datetime currentTime = TimeCurrent();\n   if(currentTime - lastNewsCheckTime < 1800)\n      return false;\n   \n   lastNewsCheckTime = currentTime;\n   return false;\n}\n\nbool InitializeMarketStructurePoints() {\n   PrintInfo("Initializing market structure points...");\n   \n   int barsNeeded = MathMax(1000, SwingSensitivity * 20);\n   MqlRates rates[];\n   \n   if(CopyRates(_Symbol, g_mainTF, 0, barsNeeded, rates) <= 0) {\n      PrintError("Error loading historical data: " + IntegerToString(GetLastError()));\n      return false;\n   }\n   \n   higherHighsCount = 0;\n   higherLowsCount = 0;\n   lowerHighsCount = 0;\n   lowerLowsCount = 0;\n   \n   for(int i = barsNeeded - SwingSensitivity*2; i >= SwingSensitivity; i--) {\n      if(IsSwingHigh(rates, i, SwingSensitivity) && higherHighsCount < MaxHistoricalLevels) {\n         higherHighs[higherHighsCount] = rates[i].high;\n         higherHighsTime[higherHighsCount] = rates[i].time;\n         higherHighsCount++;\n      }\n      \n      if(IsSwingLow(rates, i, SwingSensitivity) && higherLowsCount < MaxHistoricalLevels) {\n         higherLows[higherLowsCount] = rates[i].low;\n         higherLowsTime[higherLowsCount] = rates[i].time;\n         higherLowsCount++;\n      }\n   }\n   \n   return (higherHighsCount > 0 && higherLowsCount > 0);\n}\n\nbool IsSwingHigh(const MqlRates &rates[], int i, int sensitivity) {\n   if(i < sensitivity || i >= ArraySize(rates) - sensitivity)\n      return false;\n   \n   for(int j = 1; j <= sensitivity; j++) {\n      if(rates[i].high <= rates[i+j].high || rates[i].high <= rates[i-j].high)\n         return false;\n   }\n   return true;\n}\n\nbool IsSwingLow(const MqlRates &rates[], int i, int sensitivity) {\n   if(i < sensitivity || i >= ArraySize(rates) - sensitivity)\n      return false;\n   \n   for(int j = 1; j <= sensitivity; j++) {\n      if(rates[i].low >= rates[i+j].low || rates[i].low >= rates[i-j].low)\n         return false;\n   }\n   return true;\n}\n\nbool UpdateMarketStructure() {\n   MqlRates rates[];\n   if(CopyRates(_Symbol, g_mainTF, 0, SwingSensitivity*3, rates) <= 0)\n      return false;\n   \n   bool updated = false;\n   \n   if(IsSwingHigh(rates, SwingSensitivity)) {\n      for(int i = MaxHistoricalLevels-1; i > 0; i--) {\n         higherHighs[i] = higherHighs[i-1];\n         higherHighsTime[i] = higherHighsTime[i-1];\n      }\n      \n      higherHighs[0] = rates[SwingSensitivity].high;\n      higherHighsTime[0] = rates[SwingSensitivity].time;\n      \n      if(higherHighsCount < MaxHistoricalLevels)\n         higherHighsCount++;\n      \n      updated = true;\n      SendTelegramNotification("ðŸ“ˆ New Higher High: " + DoubleToString(higherHighs[0], _Digits));\n   }\n   \n   if(IsSwingLow(rates, SwingSensitivity)) {\n      for(int i = MaxHistoricalLevels-1; i > 0; i--) {\n         higherLows[i] = higherLows[i-1];\n         higherLowsTime[i] = higherLowsTime[i-1];\n      }\n      \n      higherLows[0] = rates[SwingSensitivity].low;\n      higherLowsTime[0] = rates[SwingSensitivity].time;\n      \n      if(higherLowsCount < MaxHistoricalLevels)\n         higherLowsCount++;\n      \n      updated = true;\n      SendTelegramNotification("ðŸ“‰ New Higher Low: " + DoubleToString(higherLows[0], _Digits));\n   }\n   \n   return updated;\n}\n\ndouble FindSupportLevel() {\n   MqlRates rates[];\n   datetime startTime = 0;\n   \n   if(higherLowsCount > 0)\n      startTime = higherLowsTime[0];\n   \n   int copied = 0;\n   if(startTime > 0) {\n      copied = CopyRates(_Symbol, g_mainTF, startTime, TimeCurrent(), rates);\n      if(copied <= 5) {\n         copied = CopyRates(_Symbol, g_mainTF, 0, 100, rates);\n      }\n   } else {\n      copied = CopyRates(_Symbol, g_mainTF, 0, 100, rates);\n   }\n   \n   if(copied <= 0)\n      return 0;\n   \n   double highestBearishLow = 0;\n   for(int i = 0; i < copied; i++) {\n      if(rates[i].close < rates[i].open) {\n         if(highestBearishLow == 0 || rates[i].low > highestBearishLow)\n            highestBearishLow = rates[i].low;\n      }\n   }\n   \n   if(highestBearishLow > 0)\n      return highestBearishLow;\n   \n   double highestLow = 0;\n   for(int i = 0; i < copied; i++) {\n      if(highestLow == 0 || rates[i].low > highestLow)\n         highestLow = rates[i].low;\n   }\n   \n   return highestLow;\n}\n\ndouble FindResistanceLevel() {\n   MqlRates rates[];\n   datetime startTime = 0;\n   \n   if(lowerHighsCount > 0)\n      startTime = lowerHighsTime[0];\n   \n   int copied = 0;\n   if(startTime > 0) {\n      copied = CopyRates(_Symbol, g_mainTF, startTime, TimeCurrent(), rates);\n      if(copied <= 5) {\n         copied = CopyRates(_Symbol, g_mainTF, 0, 100, rates);\n      }\n   } else {\n      copied = CopyRates(_Symbol, g_mainTF, 0, 100, rates);\n   }\n   \n   if(copied <= 0)\n      return 0;\n   \n   double lowestBullishHigh = 0;\n   for(int i = 0; i < copied; i++) {\n      if(rates[i].close > rates[i].open) {\n         if(lowestBullishHigh == 0 || rates[i].high < lowestBullishHigh)\n            lowestBullishHigh = rates[i].high;\n      }\n   }\n   \n   if(lowestBullishHigh > 0)\n      return lowestBullishHigh;\n   \n   double lowestHigh = 0;\n   for(int i = 0; i < copied; i++) {\n      if(lowestHigh == 0 || rates[i].high < lowestHigh)\n         lowestHigh = rates[i].high;\n   }\n   \n   return lowestHigh;\n}\n\nvoid CheckForBuySignals() {\n   if(higherHighsCount < 2 || higherLowsCount < 2) {\n      PrintDebug("Insufficient structure for buy signal");\n      return;\n   }\n   \n   bool uptrend = (higherHighs[0] > higherHighs[1]) && (higherLows[0] > higherLows[1]);\n   if(!uptrend) {\n      PrintDebug("No uptrend detected");\n      return;\n   }\n   \n   double supportLevel = FindSupportLevel();\n   if(supportLevel <= 0) {\n      PrintDebug("Support level not found");\n      return;\n   }\n   \n   double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);\n   double pipDistance = MathAbs(currentPrice - supportLevel) / _Point;\n   \n   double atr[];\n   if(CopyBuffer(iATR(_Symbol, g_mainTF, 14), 0, 0, 1, atr) <= 0) {\n      PrintError("Error getting ATR");\n      return;\n   }\n   \n   double atrPips = atr[0] / _Point;\n   double entryZonePips = MathMax(10, MathMin(atrPips * 0.5, 25));\n   \n   bool priceInZone = (pipDistance <= entryZonePips);\n   \n   if(priceInZone && CountOpenPositions(POSITION_TYPE_BUY) < MaxTrades) {\n      if(!ConfirmBuySignal()) {\n         PrintDebug("Buy signal not confirmed on lower timeframe");\n         return;\n      }\n      \n      PrintInfo("BUY SIGNAL - Support: " + DoubleToString(supportLevel, _Digits) +  \n                ", Price: " + DoubleToString(currentPrice, _Digits));\n      \n      ExecuteBuyTrade(currentPrice);\n      \n      if(UseVisualMode) {\n         buyZoneBuffer[0] = supportLevel;\n      }\n      \n      SendTelegramNotification("ðŸŸ¢ BUY SIGNAL: " + _Symbol + " at " + DoubleToString(currentPrice, _Digits));\n   }\n}\n\nvoid CheckForSellSignals() {\n   if(lowerLowsCount < 2 || lowerHighsCount < 2) {\n      PrintDebug("Insufficient structure for sell signal");\n      return;\n   }\n   \n   bool downtrend = (lowerLows[0] < lowerLows[1]) && (lowerHighs[0] < lowerHighs[1]);\n   if(!downtrend) {\n      PrintDebug("No downtrend detected");\n      return;\n   }\n   \n   double resistanceLevel = FindResistanceLevel();\n   if(resistanceLevel <= 0) {\n      PrintDebug("Resistance level not found");\n      return;\n   }\n   \n   double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_ASK);\n   double pipDistance = MathAbs(currentPrice - resistanceLevel) / _Point;\n   \n   double atr[];\n   if(CopyBuffer(iATR(_Symbol, g_mainTF, 14), 0, 0, 1, atr) <= 0) {\n      PrintError("Error getting ATR");\n      return;\n   }\n   \n   double atrPips = atr[0] / _Point;\n   double entryZonePips = MathMax(10, MathMin(atrPips * 0.5, 25));\n   \n   bool priceInZone = (pipDistance <= entryZonePips);\n   \n   if(priceInZone && CountOpenPositions(POSITION_TYPE_SELL) < MaxTrades) {\n      if(!ConfirmSellSignal()) {\n         PrintDebug("Sell signal not confirmed on lower timeframe");\n         return;\n      }\n      \n      PrintInfo("SELL SIGNAL - Resistance: " + DoubleToString(resistanceLevel, _Digits) +  \n                ", Price: " + DoubleToString(currentPrice, _Digits));\n      \n      ExecuteSellTrade(currentPrice);\n      \n      if(UseVisualMode) {\n         sellZoneBuffer[0] = resistanceLevel;\n      }\n      \n      SendTelegramNotification("ðŸ”´ SELL SIGNAL: " + _Symbol + " at " + DoubleToString(currentPrice, _Digits));\n   }\n}\n\nbool ConfirmBuySignal() {\n   MqlRates rates[];\n   if(CopyRates(_Symbol, g_confirmTF, 0, 10, rates) < 10)\n      return false;\n   \n   bool higherLowPattern = (rates[1].low > rates[2].low && rates[0].low > rates[1].low);\n   bool bullishCandle = (rates[0].close > rates[0].open) || (rates[1].close > rates[1].open);\n   \n   double rsiValues[];\n   if(CopyBuffer(iRSI(_Symbol, g_confirmTF, 14, PRICE_CLOSE), 0, 0, 3, rsiValues) <= 0)\n      return false;\n   \n   bool rsiSupport = (rsiValues[0] < 50 && rsiValues[0] > rsiValues[1]) || (rsiValues[0] < 35);\n   bool priceBounce = (rates[1].low < rates[2].low && rates[0].low > rates[1].low && rates[0].close > rates[0].open);\n   \n   int confirmationScore = (higherLowPattern ? 1 : 0) + (bullishCandle ? 1 : 0) + (rsiSupport ? 1 : 0) + (priceBounce ? 1 : 0);\n   \n   PrintDebug("Buy Confirmation - Score: " + IntegerToString(confirmationScore) + "/4");\n   \n   return confirmationScore >= 2;\n}\n\nbool ConfirmSellSignal() {\n   MqlRates rates[];\n   if(CopyRates(_Symbol, g_confirmTF, 0, 10, rates) < 10)\n      return false;\n   \n   bool lowerHighPattern = (rates[1].high < rates[2].high && rates[0].high < rates[1].high);\n   bool bearishCandle = (rates[0].close < rates[0].open) || (rates[1].close < rates[1].open);\n   \n   double rsiValues[];\n   if(CopyBuffer(iRSI(_Symbol, g_confirmTF, 14, PRICE_CLOSE), 0, 0, 3, rsiValues) <= 0)\n      return false;\n   \n   bool rsiResistance = (rsiValues[0] > 50 && rsiValues[0] < rsiValues[1]) || (rsiValues[0] > 65);\n   bool priceRejection = (rates[1].high > rates[2].high && rates[0].high < rates[1].high && rates[0].close < rates[0].open);\n   \n   int confirmationScore = (lowerHighPattern ? 1 : 0) + (bearishCandle ? 1 : 0) + (rsiResistance ? 1 : 0) + (priceRejection ? 1 : 0);\n   \n   PrintDebug("Sell Confirmation - Score: " + IntegerToString(confirmationScore) + "/4");\n   \n   return confirmationScore >= 2;\n}\n\nvoid ExecuteBuyTrade(double entryPrice) {\n   double stopLossPrice, takeProfitPrice;\n   AdaptiveRiskManagement(entryPrice, POSITION_TYPE_BUY, stopLossPrice, takeProfitPrice);\n   \n   double lotSize = LotSize;\n   if(UseAutoLotSize) {\n      double riskAmount = AccountInfoDouble(ACCOUNT_BALANCE) * (RiskPercent / 100.0);\n      double pipValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE) * (_Point / SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE));\n      double pipRisk = (entryPrice - stopLossPrice) / _Point;\n      lotSize = NormalizeDouble(riskAmount / (pipRisk * pipValue), 2);\n      lotSize = MathMax(lotSize, SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN));\n      lotSize = MathMin(lotSize, SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX));\n   }\n   \n   Trade.SetDeviationInPoints(10);\n   \n   if(!Trade.Buy(lotSize, _Symbol, 0, stopLossPrice, takeProfitPrice, "StructureEA_Buy")) {\n      PrintError("Buy Error: " + IntegerToString(GetLastError()));\n      SendTelegramNotification("âŒ BUY FAILED: " + IntegerToString(GetLastError()));\n      return;\n   }\n   \n   TradeInfo* newTrade = new TradeInfo();\n   newTrade.ticket = Trade.ResultOrder();\n   newTrade.type = POSITION_TYPE_BUY;\n   newTrade.openPrice = entryPrice;\n   newTrade.stopLoss = stopLossPrice;\n   newTrade.takeProfit = takeProfitPrice;\n   newTrade.isTrailingActive = false;\n   newTrade.openTime = TimeCurrent();\n   \n   activeTrades.Add(newTrade);\n   \n   PrintInfo("BUY EXECUTED - Ticket: " + IntegerToString(newTrade.ticket) + ", SL: " + DoubleToString(stopLossPrice, _Digits) + ", TP: " + DoubleToString(takeProfitPrice, _Digits));\n}\n\nvoid ExecuteSellTrade(double entryPrice) {\n   double stopLossPrice, takeProfitPrice;\n   AdaptiveRiskManagement(entryPrice, POSITION_TYPE_SELL, stopLossPrice, takeProfitPrice);\n   \n   double lotSize = LotSize;\n   if(UseAutoLotSize) {\n      double riskAmount = AccountInfoDouble(ACCOUNT_BALANCE) * (RiskPercent / 100.0);\n      double pipValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE) * (_Point / SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE));\n      double pipRisk = (stopLossPrice - entryPrice) / _Point;\n      lotSize = NormalizeDouble(riskAmount / (pipRisk * pipValue), 2);\n      lotSize = MathMax(lotSize, SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN));\n      lotSize = MathMin(lotSize, SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX));\n   }\n   \n   Trade.SetDeviationInPoints(10);\n   \n   if(!Trade.Sell(lotSize, _Symbol, 0, stopLossPrice, takeProfitPrice, "StructureEA_Sell")) {\n      PrintError("Sell Error: " + IntegerToString(GetLastError()));\n      SendTelegramNotification("âŒ SELL FAILED: " + IntegerToString(GetLastError()));\n      return;\n   }\n   \n   TradeInfo* newTrade = new TradeInfo();\n   newTrade.ticket = Trade.ResultOrder();\n   newTrade.type = POSITION_TYPE_SELL;\n   newTrade.openPrice = entryPrice;\n   newTrade.stopLoss = stopLossPrice;\n   newTrade.takeProfit = takeProfitPrice;\n   newTrade.isTrailingActive = false;\n   newTrade.openTime = TimeCurrent();\n   \n   activeTrades.Add(newTrade);\n   \n   PrintInfo("SELL EXECUTED - Ticket: " + IntegerToString(newTrade.ticket) + ", SL: " + DoubleToString(stopLossPrice, _Digits) + ", TP: " + DoubleToString(takeProfitPrice, _Digits));\n}\n\nint ManageOpenPositions() {\n   int positionsModified = 0;\n   \n   for(int i = PositionsTotal() - 1; i >= 0; i--) {\n      ulong ticket = PositionGetTicket(i);\n      if(ticket <= 0) continue;\n      \n      if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;\n      if(PositionGetInteger(POSITION_MAGIC) != MagicNumber) continue;\n      \n      double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);\n      double currentSL = PositionGetDouble(POSITION_SL);\n      double currentTP = PositionGetDouble(POSITION_TP);\n      double currentPrice;\n      \n      ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);\n      \n      if(posType == POSITION_TYPE_BUY)\n         currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);\n      else\n         currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_ASK);\n      \n      if(UseBreakEven) {\n         if(posType == POSITION_TYPE_BUY) {\n            double breakEvenPips = BreakEvenPips * _Point;\n            if(currentPrice >= openPrice + breakEvenPips) {\n               double newStopLoss = openPrice + BreakEvenStopPips * _Point;\n               if(newStopLoss > currentSL) {\n                  if(Trade.PositionModify(ticket, newStopLoss, currentTP)) {\n                     positionsModified++;\n                     PrintInfo("Break-even set for Buy #" + IntegerToString(ticket));\n                  }\n               }\n            }\n         } else {\n            double breakEvenPips = BreakEvenPips * _Point;\n            if(currentPrice <= openPrice - breakEvenPips) {\n               double newStopLoss = openPrice - BreakEvenStopPips * _Point;\n               if(newStopLoss < currentSL || currentSL == 0) {\n                  if(Trade.PositionModify(ticket, newStopLoss, currentTP)) {\n                     positionsModified++;\n                     PrintInfo("Break-even set for Sell #" + IntegerToString(ticket));\n                  }\n               }\n            }\n         }\n      }\n      \n      if(UseTrailingStop) {\n         if(posType == POSITION_TYPE_BUY) {\n            double activationLevel = openPrice + TrailingStartPips * _Point;\n            if(currentPrice >= activationLevel) {\n               double newStopLoss = currentPrice - TrailingStepPips * _Point;\n               if(newStopLoss > currentSL) {\n                  if(Trade.PositionModify(ticket, newStopLoss, currentTP)) {\n                     positionsModified++;\n                     PrintInfo("Trailing stop moved for Buy #" + IntegerToString(ticket));\n                  }\n               }\n            }\n         } else {\n            double activationLevel = openPrice - TrailingStartPips * _Point;\n            if(currentPrice <= activationLevel) {\n               double newStopLoss = currentPrice + TrailingStepPips * _Point;\n               if(newStopLoss < currentSL || currentSL == 0) {\n                  if(Trade.PositionModify(ticket, newStopLoss, currentTP)) {\n                     positionsModified++;\n                     PrintInfo("Trailing stop moved for Sell #" + IntegerToString(ticket));\n                  }\n               }\n            }\n         }\n      }\n   }\n   \n   return positionsModified;\n}\n\nint CountOpenPositions(ENUM_POSITION_TYPE type) {\n   int count = 0;\n   \n   for(int i = PositionsTotal() - 1; i >= 0; i--) {\n      ulong ticket = PositionGetTicket(i);\n      if(ticket <= 0) continue;\n      \n      if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;\n      if(PositionGetInteger(POSITION_MAGIC) != MagicNumber) continue;\n      \n      if(PositionGetInteger(POSITION_TYPE) == type)\n         count++;\n   }\n   \n   return count;\n}\n\nvoid AdaptiveRiskManagement(double entryPrice, ENUM_POSITION_TYPE type,  \n                           double &stopLossPrice, double &takeProfitPrice) {\n   double atr[];\n   if(CopyBuffer(iATR(_Symbol, g_mainTF, 14), 0, 0, 1, atr) <= 0) {\n      if(type == POSITION_TYPE_BUY) {\n         stopLossPrice = entryPrice - StopLossPips * _Point;\n         takeProfitPrice = entryPrice + TakeProfitPips * _Point;\n      } else {\n         stopLossPrice = entryPrice + StopLossPips * _Point;\n         takeProfitPrice = entryPrice - TakeProfitPips * _Point;\n      }\n      return;\n   }\n   \n   double atrPips = atr[0] / _Point;\n   double adaptiveSLPips = MathMax(StopLossPips, MathRound(atrPips * 1.5));\n   double adaptiveTPPips = MathMax(TakeProfitPips, MathRound(atrPips * 2.5));\n   \n   if(type == POSITION_TYPE_BUY) {\n      stopLossPrice = entryPrice - adaptiveSLPips * _Point;\n      takeProfitPrice = entryPrice + adaptiveTPPips * _Point;\n   } else {\n      stopLossPrice = entryPrice + adaptiveSLPips * _Point;\n      takeProfitPrice = entryPrice - adaptiveTPPips * _Point;\n   }\n   \n   double minStopLevel = SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL) * _Point;\n   \n   if(type == POSITION_TYPE_BUY) {\n      if(entryPrice - stopLossPrice < minStopLevel)\n         stopLossPrice = entryPrice - minStopLevel;\n      if(takeProfitPrice - entryPrice < minStopLevel)\n         takeProfitPrice = entryPrice + minStopLevel;\n   } else {\n      if(stopLossPrice - entryPrice < minStopLevel)\n         stopLossPrice = entryPrice + minStopLevel;\n      if(entryPrice - takeProfitPrice < minStopLevel)\n         takeProfitPrice = entryPrice - minStopLevel;\n   }\n   \n   PrintDebug("Risk Management - SL: " + DoubleToString(stopLossPrice, _Digits) +  \n              ", TP: " + DoubleToString(takeProfitPrice, _Digits) +  \n              ", ATR: " + DoubleToString(atrPips, 1) + " pips");\n}\n\nvoid UpdatePotentialEntryZones() {\n   ObjectsDeleteAll(0, "EntryZone_");\n   \n   if(higherHighsCount >= 2 && higherLowsCount >= 2) {\n      bool uptrend = (higherHighs[0] > higherHighs[1]) && (higherLows[0] > higherLows[1]);\n      if(uptrend) {\n         double supportLevel = FindSupportLevel();\n         if(supportLevel > 0) {\n            string buyZoneName = "EntryZone_Buy";\n            datetime currentTime = TimeCurrent();\n            datetime zoneStartTime = currentTime - 12 * PeriodSeconds(g_mainTF);\n            datetime zoneEndTime = currentTime + 36 * PeriodSeconds(g_mainTF);\n            \n            double atr[];\n            if(CopyBuffer(iATR(_Symbol, g_mainTF, 14), 0, 0, 1, atr) > 0) {\n               double atrPips = atr[0] / _Point;\n               double zonePips = MathMax(10, MathMin(atrPips * 0.5, 25));\n               \n               double upperLevel = supportLevel + zonePips * _Point;\n               double lowerLevel = supportLevel - zonePips * _Point;\n               \n               ObjectCreate(0, buyZoneName, OBJ_RECTANGLE, 0, zoneStartTime, upperLevel, zoneEndTime, lowerLevel);\n               ObjectSetInteger(0, buyZoneName, OBJPROP_COLOR, clrDarkSeaGreen);\n               ObjectSetInteger(0, buyZoneName, OBJPROP_FILL, true);\n               ObjectSetInteger(0, buyZoneName, OBJPROP_BACK, true);\n               ObjectSetString(0, buyZoneName, OBJPROP_TOOLTIP, "Buy Zone");\n            }\n         }\n      }\n   }\n   \n   if(lowerLowsCount >= 2 && lowerHighsCount >= 2) {\n      bool downtrend = (lowerLows[0] < lowerLows[1]) && (lowerHighs[0] < lowerHighs[1]);\n      if(downtrend) {\n         double resistanceLevel = FindResistanceLevel();\n         if(resistanceLevel > 0) {\n            string sellZoneName = "EntryZone_Sell";\n            datetime currentTime = TimeCurrent();\n            datetime zoneStartTime = currentTime - 12 * PeriodSeconds(g_mainTF);\n            datetime zoneEndTime = currentTime + 36 * PeriodSeconds(g_mainTF);\n            \n            double atr[];\n            if(CopyBuffer(iATR(_Symbol, g_mainTF, 14), 0, 0, 1, atr) > 0) {\n               double atrPips = atr[0] / _Point;\n               double zonePips = MathMax(10, MathMin(atrPips * 0.5, 25));\n               \n               double upperLevel = resistanceLevel + zonePips * _Point;\n               double lowerLevel = resistanceLevel - zonePips * _Point;\n               \n               ObjectCreate(0, sellZoneName, OBJ_RECTANGLE, 0, zoneStartTime, upperLevel, zoneEndTime, lowerLevel);\n               ObjectSetInteger(0, sellZoneName, OBJPROP_COLOR, clrIndianRed);\n               ObjectSetInteger(0, sellZoneName, OBJPROP_FILL, true);\n               ObjectSetInteger(0, sellZoneName, OBJPROP_BACK, true);\n               ObjectSetString(0, sellZoneName, OBJPROP_TOOLTIP, "Sell Zone");\n            }\n         }\n      }\n   }\n}\n\nvoid VisualizeStructureLevels() {\n   ObjectsDeleteAll(0, "StructureEA_");\n   \n   for(int i = 0; i < higherHighsCount && i < 5; i++) {\n      string objName = "StructureEA_HH_" + IntegerToString(i);\n      ObjectCreate(0, objName, OBJ_HLINE, 0, 0, higherHighs[i]);\n      ObjectSetInteger(0, objName, OBJPROP_COLOR, clrGreen);\n      ObjectSetInteger(0, objName, OBJPROP_STYLE, STYLE_DASH);\n      ObjectSetInteger(0, objName, OBJPROP_WIDTH, 1);\n   }\n   \n   for(int i = 0; i < higherLowsCount && i < 5; i++) {\n      string objName = "StructureEA_HL_" + IntegerToString(i);\n      ObjectCreate(0, objName, OBJ_HLINE, 0, 0, higherLows[i]);\n      ObjectSetInteger(0, objName, OBJPROP_COLOR, clrLime);\n      ObjectSetInteger(0, objName, OBJPROP_STYLE, STYLE_DOT);\n      ObjectSetInteger(0, objName, OBJPROP_WIDTH, 1);\n   }\n}\n\nvoid SendTelegramNotification(string message) {\n   if(TELEGRAM_BOT_TOKEN == "" || TelegramChatID == "")\n      return;\n   \n   string url = TELEGRAM_URL + "bot" + TELEGRAM_BOT_TOKEN + "/sendMessage?chat_id=" + TelegramChatID + "&text=" + UrlEncode(message);\n   \n   char data[], result[];\n   string result_headers;\n   \n   int res = WebRequest("GET", url, NULL, NULL, 5000, data, 0, result, result_headers);\n   \n   if(res != 200) {\n      PrintError("Telegram Error: " + IntegerToString(res));\n   }\n}\n\nstring UrlEncode(string str) {\n   string result = "";\n   \n   for(int i = 0; i < StringLen(str); i++) {\n      ushort ch = StringGetCharacter(str, i);\n      \n      if((ch >= 48 && ch <= 57) || (ch >= 65 && ch <= 90) || (ch >= 97 && ch <= 122) ||  \n         ch == 45 || ch == 46 || ch == 95 || ch == 126) {\n         result += ShortToString(ch);\n      } else {\n         result += "%" + IntegerToHexString(ch);\n      }\n   }\n   \n   return result;\n}\n\nstring IntegerToHexString(int value) {\n   string hex = "";\n   string hexChars = "0123456789ABCDEF";\n   \n   if(value < 0) value = 0;\n   \n   do {\n      int remainder = value % 16;\n      hex = StringSubstr(hexChars, remainder, 1) + hex;\n      value = (value - remainder) / 16;\n   } while(value > 0);\n   \n   if(StringLen(hex) < 2)  \n      hex = "0" + hex;\n   \n   return hex;\n}\n\nvoid PrintInfo(string message) {\n   Print("[INFO] " + message);\n}\n\nvoid PrintError(string message) {\n   Print("[ERROR] " + message);\n}\n\nvoid PrintDebug(string message) {\n   if(EnableDebugLogging)\n      Print("[DEBUG] " + message);\n}